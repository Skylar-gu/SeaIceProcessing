from shapely import geometry
from shapely.validation import make_valid
from shapely.geometry import Polygon, MultiPolygon, LineString, MultiPoint
from scipy.optimize import curve_fit
import os
import logging
import pickle
from geopy.distance import geodesic
from geotiff import GeoTiff
import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt
import rasterio

def read_image(filepath):
    with rasterio.open(filepath) as f:
        img = f.read(1)
    img = img / np.max(img) * 255
    return img.astype(np.uint8)

def callback(x):
    pass

def get_bin_img(img, h_it, v_it, threshold=190, plot=False):
    binary_img = np.where(img > 190, 255, 0)
    binary_img = binary_img.astype(np.uint8)
    binary_img = cv.erode(binary_img, (3,3), iterations=v_it)
    binary_img = cv.erode(binary_img.T, (3,3), iterations=h_it)
    binary_img = binary_img.T
    if plot: 
        plt.figure(figsize=(10, 10))
        plt.imshow(binary_img, cmap='gray')

        plt.axis('off') 
        plt.tight_layout()
        plt.show()
    return binary_img

def canny_edge_opencv(img, low, high):
    _, bin = cv.threshold(img, 5, 255, cv.THRESH_BINARY)
    kernel = np.ones((7,7), np.uint8)
    erosion = cv.erode(bin, kernel, iterations=1)
    
    binary_img = get_bin_img(img,20,20)
    edges_array = cv.Canny(binary_img, low, high) 
    return cv.bitwise_and(edges_array, edges_array, mask=erosion)

def find_contours(edges_arr, area_limit, kernel, iterations=0):
    kernel_ellipse = cv.getStructuringElement(cv.MORPH_ELLIPSE, kernel)
    dilate = cv.dilate(edges_arr, kernel_ellipse, iterations)
    cnts, _ = cv.findContours(dilate, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
    
    polygons = []
    polygon_area_list = []
    for cont in cnts:
        if cv.contourArea(cont) > area_limit:
            polygon = geometry.Polygon(np.squeeze(cont))
            polygons.append(polygon)
            polygon_area_list.append(polygon.area)
    return polygons, polygon_area_list 

def check_inside_contours(polygon_list, polygon_area_list):
    polygons = np.array(polygon_list)
    polygons_area = np.array(polygon_area_list)
    
    valid_polygons = np.array([make_valid(poly) if not poly.is_valid else poly for poly in polygons])

    to_remove = set()
    for i, poly in enumerate(valid_polygons):
        for j, other in enumerate(valid_polygons):
            if i != j and poly.contains(other):
                to_remove.add(j)
    
    mask = np.ones(len(polygons), dtype=bool)
    mask[list(to_remove)] = False
    
    polygons_indep = polygons[mask]
    polygons_area_indep = polygons_area[mask]
    
    return polygons_indep, polygons_area_indep

def check_if_ice(img, polygons, polygon_areas):
    polygons = np.array(polygons)
    polygon_areas = np.array(polygon_areas)

    binary_img = get_bin_img(img,20,20)
    binary_img = np.array(binary_img)
    to_remove = set()

    centroids = np.array([Polygon(poly).centroid for poly in polygons])

    for index, centroid in enumerate(centroids):
        i,j = centroid.x, centroid.y
        i,j=int(i),int(j)
        if binary_img[j,i] < 100:
            to_remove.add(index)

    mask = np.ones(len(polygons), dtype=bool)
    mask[list(to_remove)] = False

    floes = polygons[mask]
    floes_area = polygon_areas[mask]

    return floes, floes_area

def get_perimeter(polygons_checked):
    eroded_poly_list = list(polygons_checked)
    poly_perimeter = []
    for poly in eroded_poly_list:
        poly_perimeter.append(poly.length)
    return np.array(poly_perimeter)  

def detect_floes(polygons_checked, polygons_area_checked):
    poly_perimeter = get_perimeter(polygons_checked)
    to_remove = set()
    

    for i, poly in enumerate(polygons_checked):
        if poly_perimeter[i] > 10000:
                to_remove.add(i)

    mask = np.ones(len(polygons_checked), dtype=bool)
    mask[list(to_remove)] = False

    floe_polygons = polygons_checked[mask]
    floe_polygons_area = polygons_area_checked[mask]

    return floe_polygons, floe_polygons_area

def log_normal(x, mu, sigma):
    return (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2)) / (x * sigma * np.sqrt(2 * np.pi))) # Probability Density Function

def get_polygons(img, low=50, high=250, kernel=(3,3), area_limit=300):

    edges_arr = canny_edge_opencv(img, low, high)  
    polygons, polygon_areas = find_contours(edges_arr, area_limit, kernel)
    polygons, polygon_areas = check_if_ice(img,polygons,polygon_areas)
    polygons_checked, polygons_area_checked = check_inside_contours(polygons, polygon_areas)
    poly_floes, area_floes = detect_floes(polygons_checked, polygons_area_checked)
                
    return poly_floes, area_floes

def check_pxl_distance(filepath):
    geotiff = GeoTiff(filepath)

    coord1, coord2= geotiff.get_coords(0,1), geotiff.get_coords(0,0)
    # get coords in format (lat, lon)
    coord1, coord2 = (coord1[1],coord1[0]), (coord2[1], coord2[0])

    meter_res_pxl = round(geodesic(coord1,coord2).meters,1)
    return meter_res_pxl

def plot_polygons(img, results, polygons_checked):
    plt.figure(figsize=(10, 10))
    plt.imshow(img, cmap='gray')
    
    for polygon in polygons_checked:
        if isinstance(polygon, Polygon):
            x, y = polygon.exterior.xy
            plt.plot(x, y, linewidth=0.5, color='red') # optional: color='red'
    
    low = results['Low']
    high = results['High']
    kernel = results['Kernel']
    area_limit = results['Area_limit']

    title = f'''Image with Polygons
        Low: {low}, High: {high}, Kernel: {kernel}, Area Limit: {area_limit}
        Number of Polygons: {len(polygons_checked)}'''
              
    plt.title(title)
    
    plt.axis('off') 
    plt.tight_layout()
    plt.show()

def save_polygon_img(output_dir, results, polygons_checked):
    global filepath, filename
    img = read_image(filepath)
    plt.figure(figsize=(10, 10))  # Set a fixed figure size for consistency
    plt.imshow(img, cmap='gray')
    
    for polygon in polygons_checked:
        if isinstance(polygon, Polygon):
            x, y = polygon.exterior.xy
            plt.plot(x, y, linewidth=0.5)

    low = results['Low']
    high = results['High']
    kernel = results['Kernel']
    area_limit = results['Area_limit']
    
    title = f"{filename[:-4]} /n Low: {low}, High: {high}, Kernel: {kernel}, Area Limit: {area_limit}/n Number of Polygons: {len(polygons_checked)}"
    
              
    plt.title(title)
    
    name = f"polygon_plot_{filename}_low_{low}_high_{high}_kernel_{kernel}_area_limit_{area_limit}.pdf"

    filepath = os.path.join(output_dir, name)
    
    plt.savefig(filepath, dpi=1000, bbox_inches='tight')
    plt.close()

def linear(x, m, b):
    return m * x + b

def floe_size_distribution(output_dir, polygons_area_checked, filename, threshold = 100000):
    global filepath
    polygon_areas = np.array(polygons_area_checked)
    print(f'Original Number of Polygons: {len(polygon_areas)}')

    outliers = polygon_areas[polygon_areas > threshold]
    filtered_list = polygon_areas[polygon_areas <= threshold]
    filtered_list = np.sqrt(filtered_list / np.pi)*3 #check_pxl_distance(filepath)
    print(f'Number of Polygons Plotted: {len(filtered_list)}')

    n, bins, _ = plt.hist(filtered_list, bins=100, edgecolor='black')  # use density = True to normalize the data, n = number of values in each bin
    plt.yscale('log')

    name = f"{filename}_floe_size_distribution.pdf"
    filepath = os.path.join(output_dir, name)
    
    if filename.endswith('.tif'):
        file = filename[:-4]
    else:
        file = filename
    
    title = "Floe Size Distribution /n Number of floes plotted:',len(filtered_list),'/n',file"

    plt.title(title)
    plt.xlabel('Floe Size (m)')
    plt.ylabel('Density (log scale)')

    plt.grid(True, which="both", ls='-', alpha=0.2)

    # Calculate bin centers
    bin_centers = bins[:-1] + np.diff(bins) / 2

    # Make sure there's no division by 0
    mask = n > 0
    bin_centers = bin_centers[mask]
    n = n[mask]
    
    # Fit a linear distribution to the histogram data
    popt, _ = curve_fit(linear, bin_centers, np.log(n))

    # Plot the fitted curve
    x_interval_for_fit = np.linspace(bins[0], bins[-1], 10000)
    plt.plot(x_interval_for_fit, np.exp(linear(x_interval_for_fit, *popt)), label='Fitted Linear Curve')

    plt.legend()
    plt.tight_layout()
    plt.savefig(filepath, dpi=1000, bbox_inches='tight')
    plt.close()
    
    return outliers

filepath = #enter filepath
results = {'Low':50, 'High':150, 'Kernel':(3,3), 'Area_limit':300}
img = read_image(filepath)
